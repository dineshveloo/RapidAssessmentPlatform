{
  "_args": [
    [
      {
        "raw": "merge-anything@^2.2.4",
        "scope": null,
        "escapedName": "merge-anything",
        "name": "merge-anything",
        "rawSpec": "^2.2.4",
        "spec": ">=2.2.4 <3.0.0",
        "type": "range"
      },
      "/Users/anu/Documents/RapidAssessmentPlatform/client/node_modules/styled-components"
    ]
  ],
  "_from": "merge-anything@^2.2.4",
  "_hasShrinkwrap": false,
  "_id": "merge-anything@2.4.4",
  "_location": "/merge-anything",
  "_nodeVersion": "12.13.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/merge-anything_2.4.4_1575338357129_0.980416417448273"
  },
  "_npmUser": {
    "name": "mesqueeb",
    "email": "mesqueeb@gmail.com"
  },
  "_npmVersion": "6.12.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "merge-anything@^2.2.4",
    "scope": null,
    "escapedName": "merge-anything",
    "name": "merge-anything",
    "rawSpec": "^2.2.4",
    "spec": ">=2.2.4 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/styled-components"
  ],
  "_resolved": "https://registry.npmjs.org/merge-anything/-/merge-anything-2.4.4.tgz",
  "_shasum": "6226b2ac3d3d3fc5fb9e8d23aa400df25f98fdf0",
  "_shrinkwrap": null,
  "_spec": "merge-anything@^2.2.4",
  "_where": "/Users/anu/Documents/RapidAssessmentPlatform/client/node_modules/styled-components",
  "author": {
    "name": "Luca Ban - Mesqueeb"
  },
  "bugs": {
    "url": "https://github.com/mesqueeb/merge-anything/issues"
  },
  "dependencies": {
    "is-what": "^3.3.1"
  },
  "description": "Merge objects & other types recursively. A simple & small integration.",
  "devDependencies": {
    "@ava/babel-preset-stage-4": "^4.0.0",
    "@babel/plugin-proposal-object-rest-spread": "^7.6.2",
    "@babel/preset-env": "^7.7.1",
    "ava": "^2.4.0",
    "copy-anything": "^1.5.0",
    "rollup": "^1.27.3",
    "rollup-plugin-typescript2": "^0.25.2",
    "typescript": "^3.7.2"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-l5XlriUDJKQT12bH+rVhAHjwIuXWdAIecGwsYjv2LJo+dA1AeRTmeQS+3QBpO6lEthBMDi2IUMpLC1yyRvGlwQ==",
    "shasum": "6226b2ac3d3d3fc5fb9e8d23aa400df25f98fdf0",
    "tarball": "https://registry.npmjs.org/merge-anything/-/merge-anything-2.4.4.tgz",
    "fileCount": 16,
    "unpackedSize": 40627,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJd5cF1CRA9TVsSAnZWagAA7eoP+QFa26CLuUQ6JLv/fAVp\nG7/baH040HDV/4rXKQYWKLXVNL3TMekXPt1GT8vrDQhCSTkdGFoSlTdZduUO\nVV5nsa823xwalPYYSFohaJfOSE00Ep1j483JUyYXCLQQr9QNVUun8KXzTh16\nrS6MWwh8PcTJS+l3GQiX2tQMqzH5+BsfGwcfqWdYfCPKdpHpyEONuwpim6cz\n5W5qbPzkHOGkvT20SMsVuKqoxMOe+isCww6SBs0zifVmw7LFwo+biD2zLPlD\nbCj1bm09qA0XTaqXXPkhko4oJ1+CNsgIv5aHZCtmKCYOkuR8/MZiqEK4rfm4\nFaxACchMYUprSJFJAPflN8Me21ljO02oYInx1wwNvhKl8IkRzRtJ3zYj7+Nu\njO4utuHk7euhcjgX3MkDPer/UCb0jGAWmt3DgJOTDU+PK9xS+M/aEl9BthF9\nTCT3zN7jkO/w87VH8kr9WBUhbBhtAi1qgWJ1eVtBtIMIG4zWMYEt6ulxDAjf\ndnNC9BRlAm/vQC0rxCXSJXc958lym7hU4DvWyIbg8M01+lMo0cAgCq9Vjrzv\nhxiH+91Szdrh20h6QkHXnivr+kyzEQrqvHHlDFJn3YNdtqwWjw60Zr3LaiUb\n3o1SY9SnHzWKMMELGQ9487YpIgcSXXBstjHZDxAAwceLdG4S/RC5k8MSjv8s\nhfwv\r\n=GmV1\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "gitHead": "e9fea362f273f96201e4abfae8ef3de5e0be55a0",
  "homepage": "https://github.com/mesqueeb/merge-anything#readme",
  "keywords": [
    "javascript",
    "merge",
    "deepmerge",
    "recursively",
    "object-assign",
    "deep-assign",
    "nested-assign",
    "typescript",
    "deep-merge",
    "merge-object",
    "merge-objects",
    "deep-merge-object",
    "object-assign-deep",
    "nested-object-assign",
    "nested-merge",
    "combine",
    "combine-objects",
    "combine-merge",
    "merge-combine",
    "nested-combine"
  ],
  "license": "MIT",
  "main": "dist/index.cjs.js",
  "maintainers": [
    {
      "name": "mesqueeb",
      "email": "mesqueeb@gmail.com"
    }
  ],
  "module": "dist/index.esm.js",
  "name": "merge-anything",
  "optionalDependencies": {},
  "readme": "# Merge anything 🥡\n\n```\nnpm i merge-anything\n```\n\nMerge objects & other types recursively. A simple & small integration.\n\n## Motivation\n\nI created this package because I tried a lot of similar packages that do merging/deepmerging/recursive object assign etc. But all had its quirks, and *all of them break things they are not supposed to break*... 😞\n\nI was looking for:\n\n- a simple merge function like `Object.assign()`\n- supports merging of nested properties\n- supports symbols\n- supports enumerable & nonenumerable props\n- **does not break special class instances**　‼️\n\nThis last one is crucial! In JavaScript almost everything is _an object_, sure, but I don't want a merge function trying to merge eg. two `new Date()` instances! So many libraries use custom classes that create objects with special prototypes, and such objects all break when trying to merge them. So we gotta be careful!\n\nmerge-anything will merge objects and nested properties, but only as long as they're \"plain objects\". As soon as a sub-prop is not a \"plain object\" and has a special prototype, it will copy that instance over \"as is\". ♻️\n\n## Meet the family\n\n- [merge-anything 🥡](https://github.com/mesqueeb/merge-anything)\n- [filter-anything ⚔️](https://github.com/mesqueeb/filter-anything)\n- [find-and-replace-anything 🎣](https://github.com/mesqueeb/find-and-replace-anything)\n- [compare-anything 🛰](https://github.com/mesqueeb/compare-anything)\n- [copy-anything 🎭](https://github.com/mesqueeb/copy-anything)\n- [flatten-anything 🏏](https://github.com/mesqueeb/flatten-anything)\n- [is-what 🙉](https://github.com/mesqueeb/is-what)\n\n## Usage\n\nPass the base param first and then an unlimited amount of params to merge onto it.\n\n```js\nimport merge from 'merge-anything'\n\nconst starter = {name: 'Squirtle', type: 'water'}\nconst newValues = {name: 'Wartortle', level: 16}\n\nmerge(starter, newValues, {is: 'cool'})\n// returns {\n//   name: 'Wartortle',\n//   type: 'water,\n//   level: 16,\n//   is: 'cool'\n// }\n```\n\n## Rules\n\nThis package will recursively go through plain objects and merge the values onto a new object.\n\n> Please note that this package recognises special JavaScript objects like classes. In such cases it will not recursively merge them like objects, but assign the class onto the new object \"as is\"!\n\n```js\n// all passed objects do not get modified\nconst a = {a: 'a'}\nconst b = {b: 'b'}\nconst c = merge(a, b)\n// a === {a: 'a'}\n// b === {b: 'b'}\n// c === {a: 'a', b: 'b'}\n// However, be careful with JavaScript object references. See below: A note on JavaScript object references\n\n// arrays get overwritten\n// (for \"concat\" logic, see Extensions below)\nmerge({array: ['a']}, {array: ['b']}) // returns {array: ['b']}\n\n// empty objects merge into objects\nmerge({obj: {prop: 'a'}}, {obj: {}}) // returns {obj: {prop: 'a'}}\n\n// but non-objects overwrite objects\nmerge({obj: {prop: 'a'}}, {obj: null}) // returns {obj: null}\nmerge({obj: 'a'}, 'b') // returns 'b'\n\n// and empty objects overwrite non-objects\nmerge({prop: 'a'}, {prop: {}}) // returns {prop: {}}\n```\n\nmerge-anything properly keeps special objects intact like dates, regex, functions, class instances etc.\n\nHowever, it's **very important** you understand how to work around JavaScript object references. Please be sure to read [a note on JavaScript object references](#a-note-on-javascript-object-references) down below.\n\n## Extensions & custom rules\n\nThere might be times you need to tweak the logic when two things are merged, eg. you need arrays to be *concatenated* instead of *overwritten*. This is possible through an extension!\n\nTo keep the source code _as small as possible_ I opted for an extionsion system where you can import just the logic you need.\n\n### Concat arrays extension\n\n```js\nimport { merge, concatArrays } from 'merge-anything'\n\nmerge(\n  {extensions: [concatArrays]}, // pass your extensions like so\n  {array: ['a']},\n  {array: ['b']}\n)\n// returns {array: ['a', 'b']}\n```\n\nAll extensions get triggered at the top level and at every single nested prop. Let's look at two more examples to clarify this:\n\n```js\n// top level:\nmerge(\n  {extensions: [concatArrays]},\n  ['a'],\n  ['b']\n)\n// returns ['a', 'b']\n\n// nested props:\nmerge(\n  {extensions: [concatArrays]}, // pass your extensions like so\n  {nested: {prop: {array: ['a']}}},\n  {nested: {prop: {array: ['b']}}},\n)\n// returns {nested: {prop: {array: ['a', 'b']}}},\n```\n\nSuper simple!\n\n### Making your own extension / custom rule\n\nThe `concatArrays` extension imported above is actually just a function that takes both values it's trying to merge, and returns a new value. An \"extension\" function is triggered at the top level and on any nested props that should be merged.\n\nThis means that merge-anything can be really powerful because every step of the way **you can define rules to extend the overwrite logic.** Let's look at the `concatArrays` function as an example to see how you can write your own custom rules:\n\nYou have to define a function that receives two parameters. The first is the original value and the second is the new value that's being merged onto the original. When concatenating arrays, you can simply check if the value is an array or not and concatenate if it is.\n\n```js\nfunction concatArrays (originVal, newVal) {\n  if (Array.isArray(originVal) && Array.isArray(newVal)) {\n    // concat logic\n    return originVal.concat(newVal)\n  }\n  return newVal // always return newVal as fallback!!\n}\nmerge(\n  {extensions: [concatArrays]}, // pass your custom functions like so\n  {array: ['a']},\n  {array: ['b']}\n)\n// results in {array: ['a', 'b']}\n```\n\nPlease note that each extension-function receives an `originVal` and `newVal` and **has** to return the `newVal` on fallback no matter what. Otherwise there might be cases that the original value is overwritten with `undefined`.\n\n## A note on JavaScript object references\n\nBe careful for JavaScript object reference. Any property that's nested will be reactive and linked between the original and the merged objects! Down below we'll show how to prevent this.\n\n```js\nconst original = {airport: {airplane: 'dep. 🛫'}}\nconst extraInfo = {airport: {location: 'Brussels'}}\nconst merged = merge(original, extraInfo)\n\n// we change the airplane from departuring 🛫 to landing 🛬\nmerged.airport.airplane = 'lan. 🛬'\n(merged.airport.airplane === 'lan. 🛬') // true\n// However, `original` was also modified!\n(original.airport.airplane === 'lan. 🛬') // true\n```\n\nThe key rule to remember is:\n\n> Any property that's nested more than 1 level without an overlapping parent property will be reactive and linked in both the merge result and the source\n\nHowever, **there is a really easy solution**. We can just copy the merge result to get rid of any reactivity. For this we can use the [copy-anything](https://github.com/mesqueeb/copy-anything) library. This library also makes sure that _special class instances do not break_, so you can use it without fear of breaking stuff!\n\nSee below how we integrate 'copy-anything':\n\n```js\nimport copy from 'copy-anything'\n\nconst original = {airport: {airplane: 'dep. 🛫'}}\nconst extraInfo = {airport: {location: 'Brussels'}}\nconst merged = copy(merge(original, extraInfo))\n\n// we change the airplane from departuring 🛫 to landing 🛬\nmerged.airport.airplane = 'lan. 🛬'\n(merged.airport.airplane === 'lan. 🛬') // true\n// `original` won't be modified!\n(original.airport.airplane === 'dep. 🛫') // true\n```\n\nYou can then play around where you want to place the `copy()` function.\n\n## Source code\n\nIt is literally just going through an object recursively and assigning the values to a new object like below. However, it's wrapped to allow extra params etc. The code below is the basic integration, that will make you understand the basics how it works.\n\n```js\nimport { isPlainObject } from 'is-what'\n\nfunction mergeRecursively (origin, newComer) {\n  if (!isPlainObject(newComer)) return newComer\n  // define newObject to merge all values upon\n  const newObject = (isPlainObject(origin))\n    ? Object.keys(origin)\n      .reduce((carry, key) => {\n        const targetVal = origin[key]\n        if (!Object.keys(newComer).includes(key)) carry[key] = targetVal\n        return carry\n      }, {})\n    : {}\n  return Object.keys(newComer)\n    .reduce((carry, key) => {\n      const newVal = newComer[key]\n      const targetVal = origin[key]\n      // early return when targetVal === undefined\n      if (targetVal === undefined) {\n        carry[key] = newVal\n        return carry\n      }\n      // When newVal is an object do the merge recursively\n      if (isPlainObject(newVal)) {\n        carry[key] = mergeRecursively(targetVal, newVal)\n        return carry\n      }\n      // all the rest\n      carry[key] = newVal\n      return carry\n    }, newObject)\n}\n```\n\n\\* Of course, there are small differences with the actual source code to cope with rare cases & extra features. The actual source code is [here](https://github.com/mesqueeb/merge-anything/blob/master/src/merge.ts).\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mesqueeb/merge-anything.git"
  },
  "scripts": {
    "build": "npm run rollup && npm run test",
    "rollup": "rollup -c build/rollup.js",
    "test": "ava"
  },
  "typings": "types/index.d.ts",
  "version": "2.4.4"
}
